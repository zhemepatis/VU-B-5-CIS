# 3. Decipher Vigenere cipher when key is unknown 
# DIĘEO ETLMĘ EŽTŪY ĘEZDC BŠDHŽ 
# CIŪŽC FMVRS IĖZIY CEŠRS FDBMĖ 
# ŪYMAĘ ŠEŠĮĘ IŪLCŲ ZEŪIL CYOMĮ 
# ZIĘŠS ZĖRŠP ŪYOAK MŪŪŠG IUĘIG 
# ŪĄĘĖK ĮCDBO UPŽCC ĖEŽLH DEDVD 
# JEUEĮ ĘAŲŠG ZELIK FŲLŽŪ LMDŠT 
# ICTER HCLŽŪ TCLCŠ BESYS ĖNUIG 
# MZATĄ MŪRIC JMTŪS ĄAZNO ZIŠAE 
# ŠŲŽCŽ ĄIŪDH JYOAĖ ŠTZUG EVŪEĘ 
# DOJAF ZVZIĮ ĘPAFV ĖŽLŪS CMDŠI 
# ĖMZFC ĖŽLŽK MŲŲŠV FMHŽH FSTFS 
# BMZAE ŠŲŽCŽ ĄIĘEO EŲLVG MVUŠG 
# HIRŠM HEŲĄE ĮRDYH ĄUŠŠĘ ŠSLŽC 
# IUŪMĮ UŠHVC IUŪME IUŪDH ČMŪCL 
# BSLŲL EŽTCI CEŠMK EVŠEH HŪDEĘ 
# EVSMK MSLŽC IUŪMĖ MMPŠĘ CMŽAY 
# ŠCDDS IDPIF GOZAY BURYH FMŲZŽ 
# ŪMŠDL JYRŠS ZŲDVS DKĮŲĮ ZUJCH 
# ĄUGFC ŠMROY OERDM ŠŠDVC IUZĘŪ 
# UDLĘK MŪUŲM HIJIĖ UPDŠI ĖEHŠK 
# ZCDBĄ MMŪŽV ŪERIC FHŽII MŪDDS 
# ZHŲIL ŪIŪEĘ MAPOF ZVPIT EPTIG 
# HŲDŪV CŽTCĖ ECTCS HŪDZH FCLCL 
# ĖCLMJ ĘEZIO EŽTŪY ĘEZDS ĖVLĄS 
# FRŽYH ČEUDO MŪPUK MVĖSS EVDCČ 
# HŪDEĘ ZEŽAĮ EMŲER IUGHC MAŪŠĖ 
# ĘTEJB ŠŠLŽC ĮŪHIĄ ŠTZĘĘ JEUĮS 
# HVLLL EHDŽK ŽRDHĘ IUDČK ĖMŽIĮ 
# ŪMZIC OBZĘU VSTBS FTHŲL RMDĄS 
# ZIVŪH ĄEŽIĘ ZŠLCI MSŽYŽ FRHBK 
# UVHFV DŽLVC MFLŲH FKŲAK ŠSLĘI 
# ĖMRŠI SOZAY ĘŪLME ĮŪĮZV CMAĄH 
# ĘMHBC MAŪŲL EVZMĖ UVLČĖ UŽTĄĖ 
# ŠCHŽH ĖUGUŪ MŠTCĘ MHPAF ĘŪHCH 
# ĖMDŠO ŠMPŠS ĘERIC BOGIF ZTTBF 
# MSLĮH ĖUĖŠĮ BARŠS PMOĮŪ MŪPIĮ 
# HĘDĄR JIRRC MABŠY NRDZT MŪMĄS 
# HMPBC DEŽIĮ SAŲUY ŪIŲIC IDZBV 
# DRZAY ERDLS DKLCI ATTCG ŠĖŽFH 
# BMHŪI MHBME EPICI ĖMŪDN ČMDEI 
# ĖMHŲM SCLCL DRLIL FMDCŪ UDHCJ 
# ZŽDŠI ĘŪTFC KUŲŠJ BELER FMĘIĮ 
# ZRDLS JĮŪDĮ ZŠZBN BŽHVŽ ĄMSIC 
# FMVCC JEGIO MALČY MCTCL DRDEY 
# ŪMŲRR SEŠKC EEUFS CRDVH FMDEĮ 
# MVBMC SŪTLC FVUŠG HUŪFC SAOMS 
# HVUŠG SYOAŪ MSMŪS ČĖDBC EEPŠV 
# FRDZI IMVFD SEŽŪS SŽHŽĘ MDPIY 
# FAOEŪ UPTĄS GUPIL OIZDS ZĖŽFH 
# ČEŠAI MŽLMY MŽŪĄC DHNCK ĖMPAI 
# EVPIA MTGBL OABAI ŠŪSMĮ BŽDCI 
# ĖEPIC HU 

import utils.global_vars as gv
import utils.vigenere_cipher as vc
import utils.str_funcs as sf
from utils.friedman_test import friedman_test

gv.alphabet = "AĄBCČDEĘĖFGHIĮYJKLMNOPRSŠTUŲŪVZŽ"

text = "DIĘEOETLMĘEŽTŪYĘEZDCBŠDHŽCIŪŽCFMVRSIĖZIYCEŠRSFDBMĖŪYMAĘŠEŠĮĘIŪLCŲZEŪILCYOMĮZIĘŠSZĖRŠPŪYOAKMŪŪŠGIUĘIGŪĄĘĖKĮCDBOUPŽCCĖEŽLHDEDVDJEUEĮĘAŲŠGZELIKFŲLŽŪLMDŠTICTERHCLŽŪTCLCŠBESYSĖNUIGMZATĄMŪRICJMTŪSĄAZNOZIŠAEŠŲŽCŽĄIŪDHJYOAĖŠTZUGEVŪEĘDOJAFZVZIĮĘPAFVĖŽLŪSCMDŠIĖMZFCĖŽLŽKMŲŲŠVFMHŽHFSTFSBMZAEŠŲŽCŽĄIĘEOEŲLVGMVUŠGHIRŠMHEŲĄEĮRDYHĄUŠŠĘŠSLŽCIUŪMĮUŠHVCIUŪMEIUŪDHČMŪCLBSLŲLEŽTCICEŠMKEVŠEHHŪDEĘEVSMKMSLŽCIUŪMĖMMPŠĘCMŽAYŠCDDSIDPIFGOZAYBURYHFMŲZŽŪMŠDLJYRŠSZŲDVSDKĮŲĮZUJCHĄUGFCŠMROYOERDMŠŠDVCIUZĘŪUDLĘKMŪUŲMHIJIĖUPDŠIĖEHŠKZCDBĄMMŪŽVŪERICFHŽIIMŪDDSZHŲILŪIŪEĘMAPOFZVPITEPTIGHŲDŪVCŽTCĖECTCSHŪDZHFCLCLĖCLMJĘEZIOEŽTŪYĘEZDSĖVLĄSFRŽYHČEUDOMŪPUKMVĖSSEVDCČHŪDEĘZEŽAĮEMŲERIUGHCMAŪŠĖĘTEJBŠŠLŽCĮŪHIĄŠTZĘĘJEUĮSHVLLLEHDŽKŽRDHĘIUDČKĖMŽIĮŪMZICOBZĘUVSTBSFTHŲLRMDĄSZIVŪHĄEŽIĘZŠLCIMSŽYŽFRHBKUVHFVDŽLVCMFLŲHFKŲAKŠSLĘIĖMRŠISOZAYĘŪLMEĮŪĮZVCMAĄHĘMHBCMAŪŲLEVZMĖUVLČĖUŽTĄĖŠCHŽHĖUGUŪMŠTCĘMHPAFĘŪHCHĖMDŠOŠMPŠSĘERICBOGIFZTTBFMSLĮHĖUĖŠĮBARŠSPMOĮŪMŪPIĮHĘDĄRJIRRCMABŠYNRDZTMŪMĄSHMPBCDEŽIĮSAŲUYŪIŲICIDZBVDRZAYERDLSDKLCIATTCGŠĖŽFHBMHŪIMHBMEEPICIĖMŪDNČMDEIĖMHŲMSCLCLDRLILFMDCŪUDHCJZŽDŠIĘŪTFCKUŲŠJBELERFMĘIĮZRDLSJĮŪDĮZŠZBNBŽHVŽĄMSICFMVCCJEGIOMALČYMCTCLDRDEYŪMŲRRSEŠKCEEUFSCRDVHFMDEĮMVBMCSŪTLCFVUŠGHUŪFCSAOMSHVUŠGSYOAŪMSMŪSČĖDBCEEPŠVFRDZIIMVFDSEŽŪSSŽHŽĘMDPIYFAOEŪUPTĄSGUPILOIZDSZĖŽFHČEŠAIMŽLMYMŽŪĄCDHNCKĖMPAIEVPIAMTGBLOABAIŠŪSMĮBŽDCIĖEPICHU"
text_len = len(text)

# using Friedman test to find most probable length of key 
for i in range(3, 32):
    test_result = friedman_test(text, i)
    print(f"len: {i}, probability: {test_result}")

# when key length is 5, we see a slight bump in numbers, therefore we assume that key length is 5
# getting most frequent letters to make key from them
text_splits = sf.get_splits(text, 6)
for split in text_splits:
    frequecies = sf.count_frequencies(split)
    print(f"most frequent letters: {frequecies}")

# assuming that key is "MEDIS"
key = "MEDIS"
result = vc.decode_text(text, key)
print(result)